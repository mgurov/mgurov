<!doctype html><html lang=en-us dir=ltr><head><meta charset=utf-8><meta name=viewport content="width=device-width"><title>Talks | Mykola on Web</title>
<link rel=stylesheet href=/css/main.min.f80a4601225d35510aa3ab6034cc95a1037a9a631c80cde261a43712bb00af52.css integrity="sha256-+ApGASJdNVEKo6tgNMyVoQN6mmMcgM3iYaQ3ErsAr1I=" crossorigin=anonymous><script src=/js/main.23cd0c7d837263b9eaeb96ee2d9ccfa2969daa3fa00fa1c1fe8701a9b87251a1.js integrity="sha256-I80MfYNyY7nq65buLZzPopadqj+gD6HB/ocBqbhyUaE=" crossorigin=anonymous></script></head><body><header><h1><a href=/>Mykola on Web</a></h1><nav><ul><li><a href=/about/>about me</a></li><li><a href=/talks/>talks</a></li><li><a href=/notes/>notes</a></li></ul></nav></header><main><h1>Talks</h1><h2><a href=/talks/testing-on-production/>Testing on Production – deep backend edition</a></h2><p>Embrace Production as a first-class testing environment to decrease costs and improve quality.</p><p>Thorough testing before merging to master is great, but it doesn’t reveal the unknowns. Staging on shared environments tends to be slow, unreliable and costly to support. Why not just learn from the only true environment by conducting safe and efficient experiments?</p><p>This talk is based on my experience of increasing the delivery rate within the context of back-end systems of bol.com (one of the biggest online retailers of the Netherlands; logistics and purchasing domains), where correctness is often a bigger concern than performance, and recovery might require a bit more than users hitting the refresh button of their browser.</p><h2><a href=/talks/trunk-based-delivery/>Back to Trunk - the path of the Continuous Delivery</a></h2><p>A story of a feature team that implemented Continous Delivery accidentally.</p><p>Deploy continuously, move faster. Why? Won’t things break? What are the benefits for the teams and their stakeholders? Do those also apply to the “deep” back-end systems?</p><p>At <a href=https://bol.com>bol.com</a> (one of the biggest online retailers of the Netherlands), feature teams enjoy lots of autonomy. We can press the &ldquo;deploy&rdquo; button at any moment. Theoretically. Practically, there are non-technical obstacles, like: &ldquo;testing isn&rsquo;t complete, the rest of the changes must wait.&rdquo; Every delay adds up to the focus loss, and the pile of the undelivered risks is growing fast with every commit.</p><h2><a href=/talks/kotlin-for-testability/>Sugar rush of Kotlin for your tests</a></h2><p>Why do teams prefer Kotlin for their tests, even when their production code stays in Java?</p><p>Learn how Kotlin&rsquo;s syntax helps keep tests clean, expressive and concise.</p><h2><a href=/talks/external-context/>External domain context with Ktor and Kotlin DSL for expressive and resilient testing</a></h2>Learn how to build meaningful functional tests in isolation. The highlights of this technique are the minimal deviation from the production configuration or code, and very limited use of mocking. Thanks to higher tier positioning on the testing pyramid, the tests written with this technique are quite implementation-agnostic, and excel in supporting structural refactorings or high-level documentation of the component behavior.</main><footer><p>Anno 2025</p></footer></body></html>