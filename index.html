<!doctype html><html lang=en-us dir=ltr><head><meta name=generator content="Hugo 0.122.0"><meta charset=utf-8><meta name=viewport content="width=device-width"><title>Mykola on blog</title>
<link rel=stylesheet href=/css/main.min.5ee08123ba5f1cfeeb45d094a434a74c7a81a4bdd81617035c1f1e4667edae48.css integrity="sha256-XuCBI7pfHP7rRdCUpDSnTHqBpL3YFhcDXB8eRmftrkg=" crossorigin=anonymous><script src=/js/main.23cd0c7d837263b9eaeb96ee2d9ccfa2969daa3fa00fa1c1fe8701a9b87251a1.js integrity="sha256-I80MfYNyY7nq65buLZzPopadqj+gD6HB/ocBqbhyUaE=" crossorigin=anonymous></script></head><body><header><h1><a href=/>Mykola on blog</a></h1><nav><ul><li><a href=/posts/>posts</a></li><li><a href=/about/>about me</a></li><li><a href=/talks/>talks</a></li></ul></nav></header><main><p>Here comes home.</p><h2><a href=/talks/testing-on-production/>Testing on Production – deep backend edition</a></h2>Embrace Production as a first-class testing environment to decrease costs and improve quality.
Thorough testing before merging to master is great, but it doesn’t reveal the unknowns. Staging on shared environments tends to be slow, unreliable and costly to support. Why not just learn from the only true environment by conducting safe and efficient experiments?
This talk is based on my experience of increasing the delivery rate within the context of back-end systems of bol.<h2><a href=/talks/trunk-based-delivery/>Back to Trunk - the path of the Continuous Delivery</a></h2>A story of a feature team that implemented Continous Delivery accidentally.
Deploy continuously, move faster. Why? Won’t things break? What are the benefits for the teams and their stakeholders? Do those also apply to the “deep” back-end systems?
At bol.com (one of the biggest online retailers of the Netherlands), feature teams enjoy lots of autonomy. We can press the &ldquo;deploy&rdquo; button at any moment. Theoretically. Practically, there are non-technical obstacles, like: &ldquo;testing isn&rsquo;t complete, the rest of the changes must wait.<h2><a href=/talks/kotlin-for-testability/>Sugar rush of Kotlin for your tests</a></h2><p>Why do teams prefer Kotlin for their tests, even when their production code stays in Java?</p><p>Learn how Kotlin&rsquo;s syntax helps keep tests clean, expressive and concise.</p><h2><a href=/talks/external-context/>WIP: External domain context with Ktor and Kotlin DSL for expressive and resilient testing</a></h2>Learn how to build meaningful functional tests in isolation. The highlights of this technique are the minimal deviation from the production configuration or code, and very limited use of mocking. Thanks to higher tier positioning on the testing pyramid, the tests written with this technique are quite implementation-agnostic, and excel in supporting structural refactorings or high-level documentation of the component behavior.<h2><a href=/talks/mockless-testing/>WIP – Mocks: is more always better?</a></h2><p>Mocking and stubbing are, without any doubt, important techniques for a modern software developer to master. But can there be too much of the mocking goodness?</p><h2><a href=/about/running/>Running</a></h2>Where will I run<h2><a href=/posts/0005-reading-notes-the-art-of-action/>Reading notes on The Art of Action</a></h2>Was positively surprised by the Art of Action by Stephen Bungay.
The book explores the delicate balance of plans, actions and results in larger organisations.
One of the interesting points is that in certain aspects military thought and tradition is surprisingly more advanced than the business one - having to deal with large scale coordination 1-2 hundred years ahead of the corporations (napoleonic wars v 1970’s for the corporate world). In this sense, the bigger corporations trying to stay lean and agile should rather take the lessons from the advanced military institutions rather than try to emulate the inappropriate “startup” mentality.<h2><a href=/about/bol/>5 years at Bol</a></h2>2015-2020 I spent at <a href=./bol/>bol.com</a> , one of the largest online retailers of the Netherlands.<h2><a href=/posts/0004-programmatic-spring-transactional/>Spring @Transactional programmatically</a></h2>Beware: this post is WIP.
An an enterprise developer, it&rsquo;s easy to get used to the conveniences of Spring (Boot) so much that it becomes an issue on itself. Take @Transactional. Arguably, one of the few core features of Spring that does make us more productive in development. But at times it can be slightly inconvenient to rely solely on annotation for transaction boundary setup:
It might not be desireable to have a database transaction open throughout the whole request processing, e.<h2><a href=/posts/0003-jsonb_agg_children/>Postgres jsonb_agg children cart</a></h2><p>Selecting lists of related entities from RDBMS&rsquo;es can be a chore at times. Especially when ORM&rsquo;s aren&rsquo;t used or desired. jsonb_agg of postgres can be a convenient workaround for these cases:</p><h2><a href=/posts/0002-gcp-bucket-distributed-locking-primitive/>GCP Bucket as a Distributed Locking Primitive</a></h2><p>I was looking for a simple way to prevent business users executing same slow and expensive action simultaneously. Something like a lock file, but more distributed. And I wasn&rsquo;t very much in the mood of setting up Hazelcast or Zookeper, or a database for this kind of a trivial task.</p><h2><a href=/posts/0001-integration_tests_v_spring/>Java Integration Tests v Spring Context – when less is more</a></h2><p>When doing integration testing within a Spring (Boot) based project, we tend to use some sort of Spring context. Setting it up isn&rsquo;t free. Careless tests composition can lead to much time wasted on re-creating those contexts, and will make running tests painfully long very quickly. There are simple techniques of keeping this overhead to the minimum. Ideally – start only one test context for the whole run.</p></main><footer><p>Anno 2025</p></footer></body></html>