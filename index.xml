<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Mykola on blog</title>
    <link>https://mgurov.github.io/</link>
    <description>Recent content on Mykola on blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Tue, 30 Jul 2019 21:04:07 +0200</lastBuildDate>
    
	<atom:link href="https://mgurov.github.io/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Back to Trunk - the path of the Continuous Delivery</title>
      <link>https://mgurov.github.io/talks/trunk-based-delivery/</link>
      <pubDate>Sun, 07 Jul 2019 12:41:38 +0200</pubDate>
      
      <guid>https://mgurov.github.io/talks/trunk-based-delivery/</guid>
      <description>Deploy continuously, move faster. Why? Won’t things break? What are the benefits for the teams and their stakeholders? Do those also apply to the “deep” back-end systems?
At bol.com (one of the biggest online retailers of the Netherlands), feature teams enjoy lots of autonomy. We can press the &amp;ldquo;deploy&amp;rdquo; button at any moment. Theoretically. Practically, there are non-technical obstacles, like: &amp;ldquo;testing isn&amp;rsquo;t complete, the rest of the changes must wait.</description>
    </item>
    
    <item>
      <title>Testing on Production – deep backend edition</title>
      <link>https://mgurov.github.io/talks/testing-on-production/</link>
      <pubDate>Sun, 07 Jul 2019 12:31:38 +0200</pubDate>
      
      <guid>https://mgurov.github.io/talks/testing-on-production/</guid>
      <description>Embrace Production as a first-class testing environment to decrease costs and improve quality.
Thorough testing before merging to master is great, but it doesn’t reveal the unknowns. Staging on shared environments tends to be slow, unreliable and costly to support. Why not just learn from the only true environment by conducting safe and efficient experiments?
This talk is based on my experience of increasing the delivery rate within the context of back-end systems of bol.</description>
    </item>
    
    <item>
      <title>WIP – Mocks: is more always better?</title>
      <link>https://mgurov.github.io/talks/mockless-testing/</link>
      <pubDate>Tue, 30 Jul 2019 21:04:07 +0200</pubDate>
      
      <guid>https://mgurov.github.io/talks/mockless-testing/</guid>
      <description>&lt;p&gt;Mocking and stubbing are, without any doubt, important techniques for a modern software developer to master. But can there be too much of the mocking goodness?&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>WIP – Sprinkle sprinkle Kotlin sugar - small big shifts in test preparation</title>
      <link>https://mgurov.github.io/talks/kotlin-for-testability/</link>
      <pubDate>Sun, 07 Jul 2019 12:51:38 +0200</pubDate>
      
      <guid>https://mgurov.github.io/talks/kotlin-for-testability/</guid>
      <description>On Kotling helping to bringing the joy back to TDD</description>
    </item>
    
    <item>
      <title>GCP Bucket as a Distributed Locking Primitive</title>
      <link>https://mgurov.github.io/posts/0002-gcp-bucket-distributed-locking-primitive/</link>
      <pubDate>Sun, 07 Jul 2019 11:31:10 +0200</pubDate>
      
      <guid>https://mgurov.github.io/posts/0002-gcp-bucket-distributed-locking-primitive/</guid>
      <description>&lt;p&gt;I was looking for a simple way to prevent business users executing same slow and expensive action simultaneously. Something like a lock file, but more distributed. And I wasn&amp;rsquo;t very much in the mood of setting up Hazelcast or Zookeper, or a database for this kind of a trivial task.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Java Integration Tests v Spring Context – when less is more</title>
      <link>https://mgurov.github.io/posts/0001-integration_tests_v_spring/</link>
      <pubDate>Sat, 06 Jul 2019 23:13:31 +0200</pubDate>
      
      <guid>https://mgurov.github.io/posts/0001-integration_tests_v_spring/</guid>
      <description>&lt;p&gt;When doing integration testing within a Spring (Boot) based project, we tend to use some sort of Spring context. Setting it up isn&amp;rsquo;t free. Careless tests composition can lead to much time wasted on re-creating those contexts, and will make running tests painfully long very quickly. There are simple techniques of keeping this overhead to the minimum. Ideally – start only one test context for the whole run.&lt;/p&gt;</description>
    </item>
    
  </channel>
</rss>