<!doctype html><html lang=en-us dir=ltr><head><meta charset=utf-8><meta name=viewport content="width=device-width"><title>GCP Bucket as a Distributed Locking Primitive | Mykola on Web</title>
<link rel=stylesheet href=/css/main.min.72b77dbc6ede0c282ac64d7f1bb13955d3811a6136a045f15b6115e2e82d8694.css integrity="sha256-crd9vG7eDCgqxk1/G7E5VdOBGmE2oEXxW2EV4ugthpQ=" crossorigin=anonymous><script src=/js/main.23cd0c7d837263b9eaeb96ee2d9ccfa2969daa3fa00fa1c1fe8701a9b87251a1.js integrity="sha256-I80MfYNyY7nq65buLZzPopadqj+gD6HB/ocBqbhyUaE=" crossorigin=anonymous></script></head><body><header><h1><a href=/>Mykola on Web</a></h1><nav><ul><li><a href=/about/>about me</a></li><li><a href=/talks/>talks</a></li><li><a href=/posts/>posts</a></li></ul></nav></header><main><h1>GCP Bucket as a Distributed Locking Primitive</h1><p>I was looking for a simple way to prevent business users executing same slow and expensive action simultaneously. Something like a lock file, but more distributed. And I wasn&rsquo;t very much in the mood of setting up Hazelcast or Zookeper, or a database for this kind of a trivial task.</p><p>The app I worked with happened to use google storage buckets, which apparently offers good consistency guarantees: <a href=https://cloud.google.com/storage/docs/consistency>https://cloud.google.com/storage/docs/consistency</a></p><p>This means: if you have an access to a bucket, you can get an exclusive distributed lock a very simple way (example in kotlin):</p><pre tabindex=0><code>val lock = bucket.create(lockPath, &#34;&#34;.toByteArray(), 
    Bucket.BlobTargetOption.doesNotExist())
</code></pre><p>No need to be a member of a cluster, sit on the same environment or at all be in the environment. You can do a lock, or remove it, from your workstation with the <code>gsutil</code> if you have to.</p><p>There&rsquo;s of course a caveat. GCS won&rsquo;t handle TTL&rsquo;s for you. Not in a convenient for this case manner. Should one of your workers fail to clean the lock up after finishing their job, you have to either remove the lock manually, or add creation/mutation timestamp check to the code yourself.
Still, as a simple or temporary solution GCS is a very handy option, IMHO.</p><div><div>Tags:</div><ul><li><a href=/tags/gcp/>Gcp</a></li><li><a href=/tags/distributed-locking/>Distributed Locking</a></li></ul></div></main><footer><p>Anno 2025</p></footer></body></html>